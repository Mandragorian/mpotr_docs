%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[]{article}
\usepackage{blindtext} % Package to generate dummy text throughout this template

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{mpOTR Implementation $\bullet$ \today $\bullet$ Chaos Communication Congress} % Custom header text
\fancyfoot[CO,CE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section

\usepackage{hyperref} % For hyperlinks in the PDF

\hypersetup{colorlinks=true}

\usepackage[algoruled]{algorithm2e}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{float}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage[keys]{cryptocode}

\raggedbottom
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{An implementation of the Multi-party OTR protocol} % Article title
\author{%
\textsc{Andrikopoulos Konstantinos}\\[1ex] % Your name
\normalsize National Technical University of Athens \\ % Your institution
\normalsize University of Athens \\ % Your institution
\normalsize \href{mailto:gkonstandinos@gmail.com}{gkonstandinos@gmail.com} % Your email address
\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
\textsc{Kolotouros Dimitrios} \\[1ex] % Second author's name
\normalsize National Technical University of Athens \\ % Second author's institution
\normalsize University of Athens \\ % Your institution
\normalsize \href{dim.kolotouros@gmail.com}{dim.kolotouros@gmail.com}  % Second author's email address
\and % Uncomment if 3 authors are required, duplicate these 4 lines if more
\textsc{Aggelos Kiayias} \\[1ex] % Second author's name
\normalsize University of Edinburgh \\ % Second author's institution
\normalsize \href{mailto:akiayias@inf.ed.ac.uk}{akiayias@inf.ed.ac.uk} \\[1ex]% Second author's email address
\and% Uncomment if 3 authors are required, duplicate these 4 lines if more
\textsc{Dionysis Zindros} \\[1ex] % Second author's name
\normalsize University of Athens \\ % Second author's institution
\normalsize \href{mailto:dionyziz@di.uoa.gr}{dionyziz@di.uoa.gr} % Second author's email address
}
\date{\today} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
\noindent %\blindtext % Dummy abstract text - replace \blindtext with your abstract text
%In today's world, where the need of easy and instant communication must overcome the threat of constant and mass surveillance, the crypto community needs to come up with solutions.
%In particular, the problem of private multi-party chat protocols is one that has recently come into focus.
%While various protocols have been proposed at a theoretical level, there are not many implementations available, particularly for desktop applications.
%The mobile world is more lucky, since the Signal protocol is implemented in various apps with a large userbase, like WhatsApp, Viber and of course the Signal app itself.
%  One other proposed protocol, that is somewhat complete is the Multi-party OTR protocol.
%The mpOTR protocol is an interesting and somewhat intuitive solution to the problem at hand, however it treats the underlying subprotocols as black boxes and does not describe them in detail.
%As a result mpOTR lacks an implementation.
%In this article, we briefly introduce a completed mpOTR protocol and our efforts in implementing it as a pidgin plugin, thus providing a desktop application suitable for private multi-party chatrooms.
In a world where the need for easy instant communication must overcome the threat of constant surveillance, end-to-end encryption has become a necessity.
While some protocols enable end-to-end encryption for two parties, there are limited solutions for multiparty end-to-end encryption, particularly for desktop applications.
In this paper we describe the first implementation of mpOTR, the multiparty OTR protocol.
mpOTR achieves confidentiality, authenticity, forward secrecy, deniability, and basic consensus.
The existing theoretical introduction of mpOTR treats the undrelying subprotocols as black boxes and does not describe them in detail.
Our contributions are the complete description of the mpOTR protocol including every subprotocol detail and the first implementation of mpOTR.
Our implementation is a production-grade open source extension of the existing libotr library accompanied by a Pidgin plugin written in C.
\end{abstract}
}


%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
\lettrine[nindent=0em,lines=3]{P}idgin is the standard desktop application for instant messaging.
It is accompanied by the OTR plugin, which augments this, utilizing the OTR protocol \cite{otr} \cite{otr_improvedauth} \cite{otr_userstudy}, with end-to-end encryption, providing privacy such that only the communicating users can read the messages exchanged and even the provider of the communication service is prohibited from intercepting such messages.
The OTR plugin offers the ability for only two users to communicate at a time.
The underlying communication protocols such as XMPP often offer group chat functionality, giving the ability to open chat rooms where multiple people can communicate.
Until now, these group chats did not enjoy the benefits of end-to-end encryption.

The goal of our project is to implement a library for private group conversations.
In addition, we develop a Pidgin plugin, that uses this library in order to allow Pidgin users to communicate in a familiar environment.

Our work is heavily based on the mpOTR paper \cite{mpotr}.
Following the OTR conventions, the term "private" is used to describe the properties of casual real-life conversations:

\begin{itemize}
  \item Confidentiality\\
    Only the participants can read the messages\\[0.2cm]

  \item Authentication\\
    The participants are certain that they are talking to whom they think they are talking\\[0.2cm]

  \item Repudiation\\
    No one can prove to someone outside of the chat room that a certain participant authored a specific message\\[0.2cm]

  \item Forward Secrecy\\
    If the long term secrets are compromised no messages can be read that were authored before the compromise\\[0.2cm]

\end{itemize}

In the context of the multi-party chat room, one more property is required.
This property is called chat room transcript consistency and generally means that all participants share the same view over the messages  exchanged in a given chat room.

In order to implement the mpOTR protocol described in \cite{mpotr}, we had to specify the sub-protocols that were treated as black boxes and were not fully described.
We propose a Deniable Signature Key Exchange (DSKE) based on the pairwise triple Diffie--Hellman \cite{website:openwhisper-tdh} protocol.
For a Group Key Agreement (GKA) we use the protocol proposed in \cite{mpenc}, but using classic Diffie--Hellman (i.e. not ECDH).

We implemented the mpOTR library as part of the OTR library as seen in \href{https://github.com/Mandragorian/libotr/tree/mpotr}{our github repo\footnote{https://github.com/Mandragorian/libotr/tree/mpotr}}, which, until now, only offered private conversations between two participants.
Our plugin is based on the Pidgin-otr plugin, developed by the OTR community, and can be viewed in \href{https://github.com/Mandragorian/pidgin_otr/tree/mpotr_integration}{our github repo\footnote{https://github.com/Mandragorian/pidgin\_otr/tree/mpotr\_integration}}.
%------------------------------------------------

\section{The Protocol}
\begin{algorithm}[h]
  \KwIn{$\mathcal{P}$ : participants list}
	\KwResult{Executes a run of the mpOTR protocol}
	\Begin{

  $sid$ := Offer($\mathcal{P}$)

  $\mathcal{S}$ := DSKE($sid$, $\mathcal{P}$)

  $\mathcal{K}$ := GKA($sid$, $\mathcal{S}$, $\mathcal{P}$)

  $A$ := Attest($sid$, $\mathcal{S}$, $\mathcal{P}$)

  \If{$A$ $\ne$ "OK"}{
    \Return{"Error"}
  }

  $\mathcal{T}$ := Communication($sid$, $\mathcal{K}$, $\mathcal{S}$, $\mathcal{P}$)

  $consensus$ := Shutdown($sid$, $\mathcal{T}$, $\mathcal{S}$, $\mathcal{P}$)

  \If{$consensus$ = "consensus"}{
    \Return{"OK"}
  }
  \Else{
    \Return{"Error"}
  }

	}
	\caption{The mpOTR protocol}
	\label{mpotr_algo}
\end{algorithm}

In algorithm 1, we illustrate the protocol behaviour.
The whole protocol has been divided into sequential phases, which we call sub-protocols.
The first four of them (Offer, DSKE and GKA, Attest) are responsible for setting up all the needed parameters, for the private communication to take place.
The Communication sub-protocol is the one that governs the actual private group conversation.
Finally, the Shutdown sub-protocol is responsible for every action that needs to be done before ending each private session.
We briefly describe the function of each sub-protocol below.

During the Offer sub-protocol, the participants create a session id, $sid$.
This is a unique (with high probability) number identifying the session.

During the DSKE sub-protocol, each participant creates an association table $\mathcal{S}$ which maps each participant to the signing key he is going to use for this session.
Each participant generates an ephemeral signing key, that she will be using in order to sign her messages during this session.
This way she ensures her messages are authenticated.
Then, every participant exchanges their ephemeral signing keys with every other participant, using a Deniable Authenticated Key Exchange (DAKE) algorithm.
When all exchanges have taken place, every participant has created the association table.
The ephemeral signing keys to be used in this session are deniable.
The DSKE sub-protocol and the DAKE are described in more detail in section (\ref{subprots}.\ref{dske_subprot}).

During the GKA sub-protocol, the participants generate a shared key $\mathcal{K}$ that will be used to derive encryption keys.
The derived keys, in turn, will be used to encrypt the messages during this session.
The GKA sub-protocol is described in more detail in section (\ref{subprots}.\ref{gka_subprot}).

During the Attest sub-protocol, the participants authenticate the session id $sid$ and ensure that they agree on the association table $\mathcal{S}$.

During the Communication sub-protocol, the actual private conversation takes place.
The users use the shared secret $\mathcal{K}$, ephemeral signing keys, and the association table $\mathcal{S}$, in order to encrypt and authenticate their messages.
When this phase is finished, a transcript of the chat room $\mathcal{T}$ is returned, which contains all the messages of the chatroom, by participant.

During the Shutdown sub-protocol, the participants determine if the chat room transcript is consistent, and reveal their ephemeral signing keys.
If the transcript is indeed consistent we say that consensus has been reached.
The revelation of the ephemeral signing keys adds to the deniability property of the protocol, in the same manner the key revelation in OTR protocol does.
However, it's an optional feature, since the signing keys are deniable in the first place.

\section{The Sub-protocols}
\label{subprots}

Here we present the two sub-protocols that are left unspecified in \cite{mpotr}, namely the Deniable Signature Key Exchange (DSKE), and the Group Key Agreement(GKA).

\subsection{DSKE}
\label{dske_subprot}

In \cite{mpotr} the DSKE is partially described using a sub-sub-protocol named Deniable Authenticated Key Exchange (DAKE) as a black box.
In our implementation we use the Triple Diffie--Hellman key exchange as a DAKE.
Triple DH is an authenticated and deniable key exchange.

Each participant executes a Triple DH key exchange with every other participant in the chat room and they generate a shared secret.
Using that secret the user encrypt-then-MACs the public part of his signing key and sends it to the other participant.

After all participants have exchanged signing keys with each other in the manner stated above, they all have a signing key association table $\mathcal{S}$.
Note that the DSKE is the only step in the setup phase where $O(n^2)$ messages must be sent.
In the other setup phases and the communication phase only $O(n)$ messages are sent.

A schematic description of the protocol can be seen in figure \ref{den_ake_schematic}.

\begin{figure}[h]
  \fbox{%
    \pseudocode{%
      \textbf{Alice} \< \< \textbf{Bob} \\[][\hline]
      \text{ Choose a random number $x \in Z_p^*$ }\< \< \\
      \< \sendmessageright*{Send \ \left(g^x,g^X\right)} \< \\
      \< \< \text{ Choose a random number $y \in Z_p^*$ } \\
      \< \< s = g^{xy} || g^{Xy} || g^{Yx} \\
      \< \< k_1 = KDF_1(s), k_2=KDF_2(s) \\
      \< \sendmessageleft*{Send \ \left(g^y,g^Y\right)} \< \\
      s = g^{xy} || g^{Xy} || g^{Yx} \< \< \\
      k_1 = KDF_1(s), k_2 = KDF_2(s) \< \< \\
      \< \sendmessageright*{ Send \\ c = AES_{k_1}("confirm") \\ MAC_{k_2}(c)\ } \< \\
      \< \< \text{Verify mac} \\
      \< \< m = AES^{-1}_{k_1}(c) \\
      \< \< \text{Verify m = "confirm"} \\
      \< \sendmessageleft*{ Send \\ c = AES_{k_1}("confirm") \\ MAC_{k_2}(c)\ } \< \\
      \text{Verify mac} \< \< \\
      m = AES^{-1}_{k_1}(c) \< \< \\
      \text{Verify m = "confirm"} \\
      \< \sendmessageright*{Send \\ c = AES_{k_1}(\pk_a) \\ MAC_{k_2}(c) } \< \\
      \< \< \text{Verify mac} \\
      \< \< \text{Add $\pk_a$ to association table} \\
      \< \sendmessageleft*{Send \\ c = AES_{k_1}(\pk_b) \\ MAC_{k_2}(c) } \< \\
      \text{Verify mac} \< \<  \\
      \text{Add $\pk_b$ to association table} \< \< \\
    }
  }
  \caption{The messages exchanged between two users in order to authenticate each other's signing keys. $X$ and $Y$ are the private parts of the long term keys. $KDF_1$ and $KDF_2$ are two key derivation functions.}
  \label{den_ake_schematic}
\end{figure}

\subsection{GKA}
\label{gka_subprot}

\begin{figure}[h]
  \begin{minipage}{0.49\textwidth}
    \begin{tikzpicture}[scale=.9]
      \def \n {5}
      \def \ndec {4}
      \def \radius {3cm}
      \def \margin {8} % margin in angles, depends on the radius

      \foreach \s in {1,...,\ndec}
      {
        \node[draw, circle] at ({180 + (360/\n * (\s - 1))}:\radius) {$\s$};
        \draw[->, >=latex] ({145 + 36 + (360/\n * (\s - 1))+\margin}:\radius)
          arc ({145 + 36 + (360/\n * (\s - 1))+\margin}:{145 + 36 + 360/\n * (\s)-\margin}:\radius);
      }
      \node[draw, circle] at ({181 + 360/\n * (\n - 1)}:\radius) {$\n$};
    \end{tikzpicture}
    \caption{This diagram demonstrates the upflow of the intermediate keys}
    \label{upflow_diagr}
  \end{minipage}
  \begin{minipage}{0.49\textwidth}
    \begin{tikzpicture}[scale=.9]
      \def \n {5}
      \def \ndec {4}
      \def \radius {3cm}
      \def \margin {8} % margin in angles, depends on the radius

      \foreach \s in {1,...,\ndec}
      {
        \node[draw, circle](\s) at ({180 + (360/\n * (\s - 1))}:\radius) {$\s$};
      }
      \node[draw, circle](5) at ({181 + 360/\n * (\n - 1)}:\radius) {$\n$};
      \draw[->, >=latex] (5) -- (1);
      \draw[->, >=latex] (5) -- (2);
      \draw[->, >=latex] (5) -- (3);
      \draw[->, >=latex] (5) -- (4);
    \end{tikzpicture}
    \caption{This diagram demonstrates the downflow of the intermediate keys}
    \label{downflow_diagr}
  \end{minipage}
\end{figure}

For a GKA we use the protocol as specified in \cite{mpenc}.
Again, the basic idea used here is the Diffie--Hellman key exchange generalized for many participants.

During the GKA protocol, messages are exchanged in two phases: The upflow and the downflow phase.
During the upflow phase, the messages are exchanged between participants in a sequential manner, and each next participant calculates keys based on the accumulated messages received from the previous participant before contacting the next participant, as shown in Figure \ref{upflow_diagr}.
After the completion of the upflow phase, the last participant has collected enough data for key generation.
This data is subsequently communicated to the rest of the group during the downflow phase, as shown in Figure \ref{downflow_diagr}.

In algorithms \ref{upflow_algo}, \ref{downflow_algo}, \ref{gka_proto_algo} the main idea of the GKA we use is presented.

\begin{algorithm}[h]
	\KwIn{P : participants list}
	\KwIn {InterKeys : previous intermediate key list}
	\KwIn {X : user's secret key}
	\KwIn {N : next participant}
	\KwResult{Sends the new intermediate key list to the next participant}
	\Begin{
	inter\_key\_list := empty\_list

	inter\_key\_list.append( InterKeys.last\_elem() )

	\ForEach{k in InterKeys}
	{
		inter\_key\_list.append( $k^X$ )
	}

	send( N , P || inter\_key\_list)
	}
	\caption{Upflow Message send algorithm, send\_upflow}
	\label{upflow_algo}
\end{algorithm}

\begin{algorithm}
	\KwIn{P : participants list}
	\KwIn {InterKeys : previous intermediate key list}
	\KwIn {X : user's secret key}
	\KwIn {N : next participant}
	\KwResult{Sends the downflow intermediate key list to the other participants}
	\Begin{
	inter\_key\_list := empty\_list

	\ForEach{k in InterKeys}
	{
		inter\_key\_list.append( $k^X$ )
	}

	inter\_key\_list.reverse()

	send( N , P || inter\_key\_list)
	}
	\caption{Downflow Message send algorithm, send\_downflow}
	\label{downflow_algo}
\end{algorithm}

\begin{algorithm}[h]
	\KwIn{P : participants list}
	\KwOut{The shared secret}
	\KwResult{Executes a GKA and produces the shared secret}
	\Begin{

	prev := get\_previous\_participant()

	next := get\_next\_participant()

	x := gka\_genkey()

	\If{prev == NULL}{
		send\_upflow(P, [G], x, next)
		}
	\Else{
			m = receive\_from(prev)

			\If{ m not valid}{
					return error
			}
			\If{ next != NULL}{
				send\_upflow(P, m.key\_list, x, next)
			}
			\Else{
				final\_key := m.key\_list.last\_elem()

				s := $final\_key^x$

				send\_downflow(P, m.key\_list, x)

				return s
			}
	}

	m = wait\_for\_downflow()

	\If{m not valid}{
		return error
	}

	final\_key := m.key\_list[pos]

	s := $final\_key^x$

	return s

	}
	\caption{The GKA protocol}
	\label{gka_proto_algo}
\end{algorithm}

\section{The primitives}

\subsection{Diffie--Hellman Group}
The already existing libotr implementation of the DH key exchange is used.
As a result we use classic Diffie--Hellman , and specifically the group no. 5 \cite{website:dh-rfc} with a 1536 bit modulus.
In the algorithms presented above, all exponentiations are performed in this group.

\subsection{Encryption}
%For encryption we use AES-128 in CTR mode.
%The AES version with a 128-bit block was chosen instead of the 256-bit one, because the diffie hellman group we use does not provide 256 bit of entropy, and because of the various doubts the crypto community has about the key schedule algorithm.
For encryption we use AES-128 in CTR mode, the same cipher as the two-party OTR protocol.
We chose 128-bit AES instead of the 256-bit one because our Diffie--Hellman group does not provide 256 bit of entropy and evidence suggests that the 128-bit AES key schedule is preferred for security \cite{aes-key-recov} \cite{rijndael-improved-analysis}.

To encrypt a message, a user concatenates the shared secret with his personal id and creates a personal key.
This is the actual encryption key.
\[
k_{enc} = H(id_{personal} || master\ key)
\]
For the counter, each user stores locally his personal upper half (8 most significant bytes).
The lower half (8 least significant bytes) are always set to zero.
The top half of the counter is prepended in the sent message.
The ciphertext is produced as follows (where $ctr$ is the top half of the locally stored counter):

\[
ciphertext = AES_{CTR}(k_{enc}, ctr||0, plaintext)
\]

To decrypt a message, a user concatenates the shared secret with the id of the message's sender.
\[
k_{dec} = H(id_{sender} || master\ key)
\]
He uses the prepended top half of the counter.

\[
plaintext = AES_{CTR}(k_{dec}, ctr||0, ciphertext)
\]

This encryption scheme is used, so that the possibility that a certain encryption key and counter pair is eliminated.
If all the participants used the shared secret itself as an encryption key and two users sent a message at the same time, they would use the same counter.
This would be a catastrophic failure.

\subsection{Authentication}
For signing we use the EdDSA algorithm over the Ed25519 curve.
This signature scheme was chosen primarily because of its fast key generation.
Each message is signed as a whole.
This means that the signature covers the message and any metadata sent, like session id, counter value etc.
%------------------------------------------------

\section{The Plugin}
Now lets see in summary the workflow of the plugin.

This is what a Pidgin chat conversation looks like when no mpOTR session is taking place.
Notice the mpOTR button on the lower right corner, similar to the OTR button.

\includegraphics[scale=0.4]{not_started_unverified.png}

By clicking on the mpOTR button a user has the option to start a private conversation.
If he chooses to do so this is what he sees.

\includegraphics[scale=0.4]{started_unverified.png}

And when some texts are exchanged.

\includegraphics[scale=0.4]{talking_unverified.png}

However, our user (mandragore) hasn't verified another user (mandragore2).
This means that the conversation is unverified.
This is presented to the user in two ways.
First the mpOTR button has a yellow colour and states that the conversation is "Unverified".
Secondly, the message "You have not verified user: mandragore2".
This message will be displayed for every unverified user.

In order to verify the user mandragore2, our user clicks on the mpOTR button.
Notice how the "Start private conversation" option is now disabled.

\includegraphics[scale=0.4]{click_mpotr_button_unverified.png}

If he clicks the "Verify fingerprints" option this window opens.

\includegraphics[scale=0.4]{verification_ui_opened_unverified.png}

In this window the user can click on the user he wants to verify and (after he checks the fingerprint) click on the "Verify" button.
The selected user will now be locally marked as verified.

\includegraphics[scale=0.4]{verification_ui_selected_user_unverified.png}

\includegraphics[scale=0.4]{user_verified_unverified.png}

To end the conversation the user clicks on the mpOTR button again and selects the "End private conversation" option.

\includegraphics[scale=0.4]{finished_unverified.png}

Now if the user starts another private conversation the new session will be characterised as "Private".

\includegraphics[scale=0.4]{started_verified.png}
%------------------------------------------------

\section{Related work}
Various applications that provide end-to-end encrypted group instant messaging exist.
Signal, Viber, \mbox{WhatsApp} and the Facebook Messenger all use implementations of the Signal protocol but are not completely open source.
Cryptocat is a free software application that follows the Signal protocol approach and provides group chats.

\section{Future Work}

The chat room transcript consistency property of our implementation only assures that the users share the same view over the sets of messages sent by each participant.
However, this doesn't prevent any message reordering attacks, enabling an attacker to change the order between messages.
One possible approach woud be the use of a partial or causal ordering sub-protocol like the one presented in \cite{oldblue}.

We also consider using a cryptographic accumulator, in order to avoid keeping the actual sets of messages in memory, during the session.

Finally, we should note that mpOTR long-lived signing keys are completely different from the OTR ones, although we have implemented mpOTR as part of the OTR library.
Having to verify two different signing keys for the same person, could prove confusing for casual users.
One possible solution, we are planning to implement, is to use an already verified OTR instant messaging channel in order to exchange the mpOTR signing keys behind the scenes.

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{ccc_mpotr_pinch}
%----------------------------------------------------------------------------------------

\end{document}
